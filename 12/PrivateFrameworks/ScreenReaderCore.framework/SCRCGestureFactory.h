<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>SCRCGestureFactory.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/ScreenReaderCore.framework/SCRCGestureFactory.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/ScreenReaderCore.framework/ScreenReaderCore (562.44)
 */

@interface SCRCGestureFactory : NSObject {
    unsigned long long  _absoluteFingerCount;
    struct { 
        double horizontal; 
        double vertical; 
    }  _axisFlipper;
    <SCRCGestureFactoryCallback> * _canSplitTapDelegate;
    int  _direction;
    double  _directionalSlope;
    int  _directions;
    double  _distance;
    double  _echoWaitTime;
    struct SCRCFingerState { 
        unsigned long long identifier; 
        int xDirection; 
        int yDirection; 
        struct SCRCMathAverageValue { 
            unsigned int samples; 
            double fifo[50]; 
            int fifoIndex; 
            double sum; 
            double average; 
            double current; 
        } normalizedVelocityPerSample; 
        struct SCRCMathAverageValue { 
            unsigned int samples; 
            double fifo[50]; 
            int fifoIndex; 
            double sum; 
            double average; 
            double current; 
        } deltaXPerSample; 
        struct SCRCMathAverageValue { 
            unsigned int samples; 
            double fifo[50]; 
            int fifoIndex; 
            double sum; 
            double average; 
            double current; 
        } deltaYPerSample; 
        struct SCRCMathAverageValue { 
            unsigned int samples; 
            double fifo[50]; 
            int fifoIndex; 
            double sum; 
            double average; 
            double current; 
        } distancePerSample; 
        double distanceTraveledWithInertiaApplied; 
        bool dragStalled; 
        unsigned long long type; 
        struct CGPoint { 
            double x; 
            double y; 
        } startTouchPoint; 
        struct CGPoint { 
            double x; 
            double y; 
        } mostRecentTouchPoint; 
        struct CGPoint { 
            double x; 
            double y; 
        } lastDownPoint; 
        double pressure; 
        double altitude; 
        double azimuth; 
    }  _finger;
    unsigned short  _fingerCount;
    double  _flickVelocityThreshold;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _gutterFrame;
    <SCRCGestureFactoryCallback> * _gutterUpDelegate;
    SCRCTargetSelectorTimer * _gutterUpTimer;
    bool  _inTapSpeedRegionForDownEvent;
    double  _lastDegrees;
    double  _lastDownTime;
    unsigned short  _lastFingerCount;
    double  _lastGutterDownTime;
    double  _lastTime;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _mainFrame;
    double  _maxDimension;
    int  _orientation;
    double  _potentialTrackingStartTimestamp;
    bool  _requireUp;
    double  _scaledTrackingDistance;
    bool  _setTrackingTimer;
    struct { 
        bool isSplitting; 
        bool isTapping; 
        bool fastTrack; 
        bool tapDead; 
        bool timedOut; 
        bool active; 
        unsigned long long fingerIdentifier; 
        double fingerDownTime; 
        struct CGPoint { 
            double x; 
            double y; 
        } startTapLocation; 
        struct CGPoint { 
            double x; 
            double y; 
        } lastTapLocation; 
        struct CGPoint { 
            double x; 
            double y; 
        } primaryFingerLocation; 
        double tapDistance; 
        int state; 
    }  _split;
    SCRCGestureFactory * _splitFactory;
    <SCRCGestureFactoryCallback> * _splitTapDelegate;
    double  _stallDistance;
    double  _startDegrees;
    double  _startDistance;
    int  _state;
    struct { 
        bool isFingerCurrentlyDown; 
        bool dead; 
        bool gutterHasBeenTouched; 
        unsigned long long numFingersInCurrentGestureEvent; 
        unsigned long long totalNumFingersInGesture; 
        unsigned long long count; 
        struct CGRect { 
            struct CGPoint { 
                double x; 
                double y; 
            } origin; 
            struct CGSize { 
                double width; 
                double height; 
            } size; 
        } frame; 
        struct CGPoint { 
            double x; 
            double y; 
        } location[8]; 
        struct CGPoint { 
            double x; 
            double y; 
        } locationPerTap[8]; 
        double thisTime; 
        double lastTime; 
    }  _tap;
    unsigned long long  _tapCount;
    <SCRCGestureFactoryCallback> * _tapDelegate;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _tapFrame;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _tapMultiFrame;
    long long  _tapSpeedFingerCount;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _tapSpeedRegion;
    SCRCTargetSelectorTimer * _tapTimer;
    double  _tapVelocityThreshold;
    double  _tapVelocityThresholdForRegion;
    double  _thumbRegion;
    bool  _thumbRejectionEnabled;
    <SCRCGestureFactoryCallback> * _trackDelegate;
    SCRCTargetSelectorTimer * _trackingTimer;
}

@property (nonatomic) bool thumbRejectionEnabled;

- (void).cxx_destruct;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })_currentTapRect;
- (void)_down:(id)arg1;
- (void)_drag:(id)arg1;
- (void)_enterTrackingMode:(id)arg1;
- (void)_handleGutterUp;
- (bool)_handleSplitEvent:(id)arg1;
- (bool)_handleSplitTap;
- (void)_handleTap;
- (void)_processUpAndPost:(bool)arg1;
- (void)_up;
- (void)_updateMultiTapFrame;
- (void)_updateStartWithPoint:(struct CGPoint { double x1; double x2; })arg1 time:(double)arg2;
- (void)_updateTapState;
- (unsigned long long)absoluteFingerCount;
- (struct { int x1; int x2; double x3; double x4; double x5; double x6; unsigned long long x7; unsigned long long x8; unsigned long long x9; bool x10; struct CGPoint { double x_11_1_1; double x_11_1_2; } x11; double x12; double x13; double x14; struct CGPoint { double x_15_1_1; double x_15_1_2; } x15; struct CGPoint { double x_16_1_1; double x_16_1_2; } x16; struct CGPoint { double x_17_1_1; double x_17_1_2; } x17; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_18_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_18_1_2; } x18; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_19_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_19_1_2; } x19; struct CGPoint { double x_20_1_1; double x_20_1_2; } x20; struct CGPoint { double x_21_1_1; double x_21_1_2; } x21; double x22; })captureCurrentState;
- (void)dealloc;
- (int)direction;
- (double)directionalSlope;
- (double)distance;
- (struct CGPoint { double x1; double x2; })endLocation;
- (unsigned long long)fingerCount;
- (double)firstFingerAltitude;
- (double)firstFingerAzimuth;
- (double)firstFingerPressure;
- (double)flickSpeed;
- (int)gestureState;
- (id)gestureStateString;
- (struct { int x1; int x2; double x3; double x4; double x5; double x6; unsigned long long x7; unsigned long long x8; unsigned long long x9; bool x10; struct CGPoint { double x_11_1_1; double x_11_1_2; } x11; double x12; double x13; double x14; struct CGPoint { double x_15_1_1; double x_15_1_2; } x15; struct CGPoint { double x_16_1_1; double x_16_1_2; } x16; struct CGPoint { double x_17_1_1; double x_17_1_2; } x17; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_18_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_18_1_2; } x18; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_19_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_19_1_2; } x19; struct CGPoint { double x_20_1_1; double x_20_1_2; } x20; struct CGPoint { double x_21_1_1; double x_21_1_2; } x21; double x22; })handleGestureEvent:(id)arg1;
- (id)initWithSize:(struct CGSize { double x1; double x2; })arg1 delegate:(id)arg2;
- (id)initWithSize:(struct CGSize { double x1; double x2; })arg1 delegate:(id)arg2 threadKey:(id)arg3;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })mainFrame;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })multiTapFrame;
- (int)orientation;
- (struct CGPoint { double x1; double x2; })rawAverageLocation;
- (struct CGPoint { double x1; double x2; })rawLocation;
- (void)reset;
- (void)setFlickSpeed:(double)arg1;
- (void)setOrientation:(int)arg1;
- (void)setTapSpeed:(double)arg1;
- (void)setTapSpeedTimeThreshold:(double)arg1 forRegion:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2 fingerCount:(long long)arg3;
- (void)setThumbRejectionEnabled:(bool)arg1;
- (struct CGPoint { double x1; double x2; })startLocation;
- (unsigned long long)tapCount;
- (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })tapFrame;
- (double)tapInterval;
- (bool)tapIsDown;
- (struct CGPoint { double x1; double x2; })tapPoint;
- (struct CGPoint { double x1; double x2; })tapPointWeightedToSides;
- (double)tapSpeed;
- (bool)thumbRejectionEnabled;
- (double)vector;
- (double)velocity;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
