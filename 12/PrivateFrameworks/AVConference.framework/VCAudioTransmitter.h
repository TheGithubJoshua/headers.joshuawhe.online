<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>VCAudioTransmitter.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/AVConference.framework/VCAudioTransmitter.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/AVConference.framework/AVConference (1475.1.8)
 */

@interface VCAudioTransmitter : NSObject <VCAudioIOSink, VCConnectionChangedHandler> {
    int  _actualAudioSendingBitrate;
    struct tagHANDLE { int x1; } * _afrc;
    bool  _allowAudioSwitching;
    VCPacketBundler * _audioBundler;
    unsigned int  _audioFrameCounter;
    int  _audioHeaderSize;
    double  _audioInterval;
    NSMutableArray * _audioPayloads;
    int  _audioTierChangeRequestCount;
    bool  _audioTierHysteresis;
    VCAudioTierPicker * _audioTierPicker;
    int  _audioTxBitrate;
    float  _blockSeconds;
    long long  _blockSize;
    void * _controlInfoGenerator;
    unsigned int  _currentAudioCap;
    VCAudioPayload * _currentAudioPayload;
    VCAudioTier * _currentAudioTier;
    struct { 
        unsigned int averageNetworkBitrate; 
        unsigned int averageMediaBitrate; 
        double averageFramerate; 
    }  _currentChannelMetrics;
    bool  _currentDTXEnable;
    VCAudioPayload * _currentDTXPayload;
    unsigned int  _currentDuplication;
    int  _currentRedPayloadType;
    unsigned int  _currentTargetBitrate;
    id  _delegate;
    struct opaqueVCAudioBufferList { } * _encodeBuffer;
    unsigned int  _encodedBytes;
    unsigned int  _estimateTxAudioBytes;
    struct { 
        unsigned short streamIDs[12]; 
        unsigned char numOfStreamIDs; 
        bool probingGroupIDIsSet; 
        unsigned short probingGroupID; 
        unsigned char priority; 
        bool pktCountingFlag; 
        bool participantIDIsSet; 
        unsigned long long participantID; 
        bool participantGenerationCounterIsSet; 
        bool ignorePriority; 
        bool statsIDIsSet; 
        unsigned short statsID; 
        struct { 
            unsigned short serverTimestamp; 
            unsigned short serverPacketInterval; 
            unsigned short totalServerPacketReceived; 
            unsigned short totalServerPacketSent; 
            unsigned short uplinkBandwidthEstimate; 
        } statsPayload; 
        bool isTransitionPacket; 
    }  _idsChannelDataFormat;
    bool  _ignoreSilence;
    bool  _includeRedSequenceOffset;
    struct AudioStreamBasicDescription { 
        double mSampleRate; 
        unsigned int mFormatID; 
        unsigned int mFormatFlags; 
        unsigned int mBytesPerPacket; 
        unsigned int mFramesPerPacket; 
        unsigned int mBytesPerFrame; 
        unsigned int mChannelsPerFrame; 
        unsigned int mBitsPerChannel; 
        unsigned int mReserved; 
    }  _inputFormat;
    unsigned char  _inputMeter;
    bool  _isAudioStalled;
    bool  _isConnectedOnIPv6_LowestConnectionQuality;
    bool  _isLocalCellular_LowestConnectionQuality;
    bool  _isRedEnabled;
    bool  _isRemoteCellular_LowestConnectionQuality;
    bool  _isUseCaseWatchContinuity;
    bool  _lastAudioStalled;
    char * _lastInputSampleBuffer;
    unsigned int  _lastInputSampleBufferSize;
    bool  _lastIsTalking;
    double  _lastReportingCallbackTime;
    unsigned int  _lastSentAudioSampleTime;
    double  _lastTierSwitch;
    double  _lastUpdateQualityIndicator;
    unsigned int  _maxIDSStreamIdCount;
    struct tagHANDLE { int x1; } * _mediaQueue;
    bool  _needsPacketThread;
    int  _operatingMode;
    void * _packetThread;
    int  _qualityIndicator;
    unsigned int  _rateChangeCounter;
    VCAudioRedBuilder * _redBuilder;
    unsigned int  _redMaxDelay20ms;
    unsigned int  _redNumPayloads;
    VCRedundancyControllerAudio * _redundancyController;
    unsigned int  _redundancyControllerMaxDelay20ms;
    unsigned int  _redundancyControllerNumPayloads;
    double  _redundancyInterval;
    unsigned int  _redundancyPercentage;
    struct opaqueRTCReporting { } * _reportingAgent;
    int  _reportingModuleID;
    VCAudioTier * _requestedAudioTier;
    struct tagHANDLE { int x1; } * _rtpHandle;
    struct tagHANDLE { int x1; } * _rtpVideo;
    unsigned int  _sampleRate;
    unsigned int  _samplesPerFrame;
    bool  _sendActiveVoiceOnly;
    unsigned int  _sentAudioBytes;
    unsigned int  _silenceFrameCounter;
    AVCStatisticsCollector * _statisticsCollector;
    NSArray * _supportedNumRedundantPayload;
    bool  _supportsAdaptation;
    unsigned int  _targetBitrate;
    unsigned int  _tierNetworkBitrate;
    unsigned int  _totalTxAudioBytes;
    bool  _transmitROC;
    VCTransportSession * _transportSession;
    bool  _useRateControl;
    unsigned int  _vadSegmentCounter;
}

@property (nonatomic, readonly) int actualAudioSendingBitrate;
@property (nonatomic, readonly) VCPacketBundler *audioBundler;
@property (nonatomic, readonly) int audioTxBitrate;
@property (nonatomic, readonly) VCAudioPayloadConfig *currentAudioPayloadConfig;
@property (nonatomic, readonly) VCAudioTier *currentAudioTier;
@property (nonatomic) struct { unsigned int x1; unsigned int x2; double x3; } currentChannelMetrics;
@property (getter=isCurrentDTXEnabled, nonatomic) bool currentDTXEnable;
@property (readonly, copy) NSString *debugDescription;
@property <VCAudioTransmitterDelegate> *delegate;
@property (readonly, copy) NSString *description;
@property (nonatomic, readonly) NSDictionary *dtxMetrics;
@property (nonatomic, readonly) unsigned int encodedBytes;
@property (readonly) unsigned long long hash;
@property (nonatomic, readonly) bool ignoreSilence;
@property unsigned char inputMeter;
@property (nonatomic) bool isAudioStalled;
@property (nonatomic, readonly) bool isRedEnabled;
@property (nonatomic, readonly) unsigned int lastSentAudioSampleTime;
@property (nonatomic) unsigned int maxIDSStreamIdCount;
@property (nonatomic) int operatingMode;
@property (nonatomic) int qualityIndicator;
@property (nonatomic) unsigned int rateChangeCounter;
@property (nonatomic, readonly) unsigned int redMaxDelay20ms;
@property (nonatomic, readonly) unsigned int redNumPayloads;
@property (nonatomic) bool sendActiveVoiceOnly;
@property (nonatomic, readonly) unsigned int sentAudioBytes;
@property (readonly) Class superclass;
@property (nonatomic, retain) NSArray *supportedNumRedundantPayload;
@property (nonatomic) unsigned int targetBitrate;

- (int)actualAudioSendingBitrate;
- (bool)allocateLastInputSampleBuffer:(unsigned int)arg1;
- (id)audioBundler;
- (int)audioTxBitrate;
- (int)bundleAndSendSamples:(char *)arg1 numEncodedBytes:(int)arg2 withPayload:(int)arg3 timeStamp:(unsigned int)arg4 bufferedSamples:(int)arg5 hasNewSamples:(bool)arg6 voiceActivity:(bool)arg7 priority:(unsigned char)arg8;
- (bool)chooseAudioNetworkBitrate;
- (id)currentAudioPayloadConfig;
- (id)currentAudioTier;
- (struct { unsigned int x1; unsigned int x2; double x3; })currentChannelMetrics;
- (void)dealloc;
- (id)delegate;
- (id)dtxMetrics;
- (int)encodeAudio:(struct opaqueVCAudioBufferList { }*)arg1 numInputSamples:(int)arg2 outputBytes:(void*)arg3 numOutputBytes:(int)arg4 withPayload:(int*)arg5 isTalking:(bool)arg6;
- (void)encodeBundleAndSendAudio:(struct opaqueVCAudioBufferList { }*)arg1 sampleCount:(unsigned int)arg2;
- (unsigned int)encodedBytes;
- (void*)generateControlInfo;
- (void)handleActiveConnectionChange:(id)arg1;
- (bool)handleCodecRateModeChange:(unsigned char)arg1 withBitrate:(unsigned int)arg2;
- (bool)ignoreSilence;
- (void)initAudioValues;
- (id)initWithConfig:(id)arg1;
- (unsigned char)inputMeter;
- (bool)isAudioStalled;
- (bool)isCurrentDTXEnabled;
- (bool)isLocalOrRemoteOnCellular;
- (bool)isRedEnabled;
- (unsigned int)lastSentAudioSampleTime;
- (void)logTierInfo:(int)arg1;
- (unsigned int)maxIDSStreamIdCount;
- (unsigned int)maximumSamplesPerFrame;
- (float)nextAudioInterval:(int)arg1;
- (int)operatingMode;
- (void)pushAudioSamples:(struct opaqueVCAudioBufferList { }*)arg1;
- (int)qualityIndicator;
- (unsigned int)rateChangeCounter;
- (unsigned int)redMaxDelay20ms;
- (unsigned int)redNumPayloads;
- (void)redundancyController:(id)arg1 redundancyIntervalDidChange:(double)arg2;
- (void)redundancyController:(id)arg1 redundancyPercentageDidChange:(unsigned int)arg2;
- (unsigned int)redundancyControllerModeForOperatingMode:(int)arg1 isRedEnabled:(bool)arg2;
- (void)registerReportingTask;
- (void)removeUnusedAudioPayloads;
- (void)reportRedundancyConfigChange;
- (bool)sendActiveVoiceOnly;
- (int)sendAudioBundle:(bool)arg1 atTimeStamp:(unsigned int)arg2 nextInterval:(float)arg3;
- (int)sendAudioPacket:(struct tagAudioPacketData { struct tagAudioHeaderData { int x_1_1_1; unsigned int x_1_1_2; unsigned char x_1_1_3[16]; unsigned char x_1_1_4; float x_1_1_5; int x_1_1_6; int x_1_1_7; int x_1_1_8; unsigned char x_1_1_9; } x1; char *x2; int x3; })arg1;
- (int)sendAudioPacket:(char *)arg1 payloadLength:(int)arg2 payloadType:(int)arg3 timestamp:(unsigned int)arg4 priority:(unsigned char)arg5 marker:(int)arg6 nextInterval:(float)arg7 padding:(char *)arg8 paddingLength:(unsigned char)arg9 sendReport:(int)arg10;
- (bool)sendAudioPacketImpl:(struct tagAudioPacketData { struct tagAudioHeaderData { int x_1_1_1; unsigned int x_1_1_2; unsigned char x_1_1_3[16]; unsigned char x_1_1_4; float x_1_1_5; int x_1_1_6; int x_1_1_7; int x_1_1_8; unsigned char x_1_1_9; } x1; char *x2; int x3; }*)arg1 bytesSent:(int*)arg2;
- (unsigned int)sentAudioBytes;
- (void)setCellTech:(int)arg1 remoteCellular:(int)arg2 isIPV6:(int)arg3 audioCap:(unsigned int)arg4;
- (void)setCurrentChannelMetrics:(struct { unsigned int x1; unsigned int x2; double x3; })arg1;
- (void)setCurrentDTXEnable:(bool)arg1;
- (void)setDelegate:(id)arg1;
- (void)setInputMeter:(unsigned char)arg1;
- (void)setIsAudioStalled:(bool)arg1;
- (void)setMaxIDSStreamIdCount:(unsigned int)arg1;
- (void)setOperatingMode:(int)arg1;
- (void)setQualityIndicator:(int)arg1;
- (void)setRateChangeCounter:(unsigned int)arg1;
- (void)setRedNumPayloads:(int)arg1 withMaxDelay:(int)arg2;
- (void)setSendActiveVoiceOnly:(bool)arg1;
- (void)setStreamIDs:(id)arg1;
- (void)setSupportedNumRedundantPayload:(id)arg1;
- (void)setTargetBitrate:(unsigned int)arg1;
- (bool)setupAudio:(id*)arg1;
- (bool)setupAudioEncoders;
- (void)setupAudioHeaderSize;
- (bool)setupAudioTierPicker;
- (bool)shouldUseDtx;
- (void)start;
- (void)stop;
- (id)supportedNumRedundantPayload;
- (unsigned int)targetBitrate;
- (void)updateAudioTxBitrate;
- (void)useAudioPayload:(id)arg1 withBitrate:(unsigned int)arg2;
- (void)useAudioTier:(id)arg1;
- (id)usedAudioPayloadForType:(int)arg1;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
