<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AXOrator.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/AccessibilityUtilities.framework/AXOrator.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/AccessibilityUtilities.framework/AccessibilityUtilities (1.0)
 */

@interface AXOrator : NSObject <AVSpeechSynthesizerDelegate> {
    double  _audioInterruptionStartedTime;
    AXDispatchTimer * _audioSessionTimer;
    bool  _contentIsSpeakable;
    NSString * _currentLanguageCode;
    <AXOratorDelegate> * _delegate;
    bool  _didRequestPauseSpeakingDuringAudioInterruption;
    bool  _didRequestResumeSpeakingDuringAudioInterruption;
    bool  _didRequestStartSpeakingDuringAudioInterruption;
    bool  _isAudioSessionActive;
    bool  _isInAudioInterruption;
    struct _NSRange { 
        unsigned long long location; 
        unsigned long long length; 
    }  _lastSpokenSubstringRange;
    AVSpeechUtterance * _lastUtterance;
    NSString * _lastUtteranceLanguageCode;
    AXLanguageTag * _lastUtteranceLanguageTag;
    struct _NSRange { 
        unsigned long long location; 
        unsigned long long length; 
    }  _lastUtteranceSubstringRange;
    unsigned long long  _numberOfTokensToSkip;
    bool  _pendingAudioSessionActive;
    bool  _preferredLanguageWasSpecified;
    NSString * _requestedLanguageCodeDuringAudioInterruption;
    AXLanguageTaggedContent * _selectedContent;
    bool  _shouldSpeakNextItemOnResume;
    AXLanguageTaggedContent * _speakingContent;
    NSArray * _speakingContentTokenRanges;
    long long  _speakingContext;
    NSMutableArray * _speechSequenceItems;
    AVSpeechSynthesizer * _speechSynthesizer;
    bool  _spellOutContent;
    AVSpeechUtterance * _statusUtterance;
    NSString * _voiceIdentifier;
    bool  _wasSpeakingBeforeAudioInterruption;
}

@property (nonatomic) double audioInterruptionStartedTime;
@property (nonatomic, copy) NSString *content;
@property (nonatomic, retain) NSString *currentLanguageCode;
@property (readonly, copy) NSString *debugDescription;
@property (nonatomic) <AXOratorDelegate> *delegate;
@property (readonly, copy) NSString *description;
@property (nonatomic) bool didRequestPauseSpeakingDuringAudioInterruption;
@property (nonatomic) bool didRequestResumeSpeakingDuringAudioInterruption;
@property (nonatomic) bool didRequestStartSpeakingDuringAudioInterruption;
@property (readonly) unsigned long long hash;
@property (nonatomic) bool isAudioSessionActive;
@property (nonatomic) bool isInAudioInterruption;
@property (nonatomic) struct _NSRange { unsigned long long x1; unsigned long long x2; } lastSpokenSubstringRange;
@property (nonatomic, retain) AVSpeechUtterance *lastUtterance;
@property (nonatomic, retain) NSString *lastUtteranceLanguageCode;
@property (nonatomic, retain) AXLanguageTag *lastUtteranceLanguageTag;
@property (nonatomic) struct _NSRange { unsigned long long x1; unsigned long long x2; } lastUtteranceSubstringRange;
@property (nonatomic) unsigned long long numberOfTokensToSkip;
@property (nonatomic) bool pendingAudioSessionActive;
@property (nonatomic) bool preferredLanguageWasSpecified;
@property (nonatomic, copy) NSString *requestedLanguageCodeDuringAudioInterruption;
@property (nonatomic, retain) AXLanguageTaggedContent *selectedContent;
@property (nonatomic) bool shouldSpeakNextItemOnResume;
@property (nonatomic, retain) AXLanguageTaggedContent *speakingContent;
@property (nonatomic, retain) NSArray *speakingContentTokenRanges;
@property (nonatomic) long long speakingContext;
@property (nonatomic, retain) NSMutableArray *speechSequenceItems;
@property (nonatomic, retain) AVSpeechSynthesizer *speechSynthesizer;
@property (nonatomic) bool spellOutContent;
@property (readonly) Class superclass;
@property (nonatomic, retain) NSString *voiceIdentifier;
@property (nonatomic) bool wasSpeakingBeforeAudioInterruption;

- (void).cxx_destruct;
- (bool)_canSpeakTaggedContent:(id)arg1;
- (bool)_changeSpeakingSpeed:(bool)arg1;
- (void)_clearAllContentState;
- (long long)_currentTokenIndex:(bool)arg1;
- (void)_didBeginInterruption;
- (void)_didEndInterruption;
- (id)_getLangCodeForItem:(id)arg1;
- (void)_handleAudioInterruption:(id)arg1;
- (void)_handleMediaServicesWereLost:(id)arg1;
- (void)_handleMediaServicesWereReset:(id)arg1;
- (void)_respeakUtteranceIfNeeded;
- (void)_setAudioSessionActive:(bool)arg1;
- (bool)_skipByUnit:(bool)arg1 boundary:(unsigned long long)arg2;
- (void)_speakNextItemInSequence;
- (void)_speakNextTokenFromCurrentTokenIndex:(long long)arg1 forward:(bool)arg2 boundary:(unsigned long long)arg3;
- (id)_speechSequenceItemsStartingAtContentLocation:(unsigned long long)arg1;
- (void)_startSpeakingSequence;
- (bool)_successWithCode:(long long)arg1 error:(id*)arg2;
- (void)_tokenizeContentIfNeeded;
- (void)_updateAudioSessionCategory;
- (void)_updateSequenceForSpellOutBehavior;
- (double)audioInterruptionStartedTime;
- (bool)canResumeWithContent:(id)arg1;
- (void)clearSelectedContent;
- (id)content;
- (bool)contentIsSpeakable;
- (id)currentLanguageCode;
- (void)dealloc;
- (id)delegate;
- (bool)didRequestPauseSpeakingDuringAudioInterruption;
- (bool)didRequestResumeSpeakingDuringAudioInterruption;
- (bool)didRequestStartSpeakingDuringAudioInterruption;
- (bool)fastForwardWithBoundary:(unsigned long long)arg1;
- (id)init;
- (bool)isAudioSessionActive;
- (bool)isInAudioInterruption;
- (bool)isPaused;
- (bool)isSpeaking;
- (struct _NSRange { unsigned long long x1; unsigned long long x2; })lastSpokenSubstringRange;
- (id)lastUtterance;
- (id)lastUtteranceLanguageCode;
- (id)lastUtteranceLanguageTag;
- (struct _NSRange { unsigned long long x1; unsigned long long x2; })lastUtteranceSubstringRange;
- (unsigned long long)numberOfTokensToSkip;
- (bool)pauseSpeaking:(id*)arg1;
- (bool)pendingAudioSessionActive;
- (bool)preferredLanguageWasSpecified;
- (id)requestedLanguageCodeDuringAudioInterruption;
- (bool)resumeSpeaking:(id*)arg1;
- (bool)resumeSpeakingAfterDelay:(double)arg1 error:(id*)arg2;
- (bool)rewindWithBoundary:(unsigned long long)arg1;
- (id)selectedContent;
- (void)setAudioInterruptionStartedTime:(double)arg1;
- (void)setContent:(id)arg1;
- (void)setCurrentLanguageCode:(id)arg1;
- (void)setDelegate:(id)arg1;
- (void)setDidRequestPauseSpeakingDuringAudioInterruption:(bool)arg1;
- (void)setDidRequestResumeSpeakingDuringAudioInterruption:(bool)arg1;
- (void)setDidRequestStartSpeakingDuringAudioInterruption:(bool)arg1;
- (void)setIsAudioSessionActive:(bool)arg1;
- (void)setIsInAudioInterruption:(bool)arg1;
- (void)setLastSpokenSubstringRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (void)setLastUtterance:(id)arg1;
- (void)setLastUtteranceLanguageCode:(id)arg1;
- (void)setLastUtteranceLanguageTag:(id)arg1;
- (void)setLastUtteranceSubstringRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (void)setNumberOfTokensToSkip:(unsigned long long)arg1;
- (void)setPendingAudioSessionActive:(bool)arg1;
- (void)setPreferredLanguageWasSpecified:(bool)arg1;
- (void)setRequestedLanguageCodeDuringAudioInterruption:(id)arg1;
- (void)setSelectedContent:(id)arg1;
- (void)setShouldSpeakNextItemOnResume:(bool)arg1;
- (void)setSpeakingContent:(id)arg1;
- (void)setSpeakingContentTokenRanges:(id)arg1;
- (void)setSpeakingContext:(long long)arg1;
- (void)setSpeechSequenceItems:(id)arg1;
- (void)setSpeechSynthesizer:(id)arg1;
- (void)setSpellOutContent:(bool)arg1;
- (void)setVoiceIdentifier:(id)arg1;
- (void)setWasSpeakingBeforeAudioInterruption:(bool)arg1;
- (bool)shouldSpeakNextItemOnResume;
- (bool)speakFaster;
- (bool)speakSlower;
- (void)speakStatusWithLanguage:(id)arg1 rate:(id)arg2;
- (id)speakingContent;
- (id)speakingContentTokenRanges;
- (long long)speakingContext;
- (float)speechRate;
- (id)speechSequenceItems;
- (id)speechSynthesizer;
- (void)speechSynthesizer:(id)arg1 didCancelSpeechUtterance:(id)arg2;
- (void)speechSynthesizer:(id)arg1 didContinueSpeechUtterance:(id)arg2;
- (void)speechSynthesizer:(id)arg1 didFinishSpeechUtterance:(id)arg2;
- (void)speechSynthesizer:(id)arg1 didPauseSpeechUtterance:(id)arg2;
- (void)speechSynthesizer:(id)arg1 didStartSpeechUtterance:(id)arg2;
- (void)speechSynthesizer:(id)arg1 willSpeakRangeOfSpeechString:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg2 utterance:(id)arg3;
- (bool)spellOutContent;
- (bool)startSpeakingWithPreferredLanguage:(id)arg1 delayBeforeStart:(double)arg2 error:(id*)arg3;
- (bool)startSpeakingWithPreferredLanguage:(id)arg1 error:(id*)arg2;
- (bool)stopSpeaking:(id*)arg1;
- (id)voiceIdentifier;
- (bool)wasSpeakingBeforeAudioInterruption;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
