<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PKCanvasView.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/PencilKit.framework/PKCanvasView.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/PencilKit.framework/PencilKit (1)
 */

@interface PKCanvasView : UIView <PKDrawableView, PKInternalDrawingViewDelegate, PKSelectionDelegate, PKToolPickerDelegate, UIDropInteractionDelegate> {
    bool  __maintainsTransformsOnLayout;
    long long  _aggd_cachedVisibleStrokeCount;
    UIColor * _backgroundColor;
    UIImage * _backgroundImage;
    <PKCanvasViewDelegate> * _delegate;
    PKInternalDrawingView * _drawingView;
    double  _fixedDrawingScale;
    struct CGSize { 
        double width; 
        double height; 
    }  _fixedPixelSize;
    bool  _layerFixedPixelSize;
    PKRecognitionOverlayView * _overlayView;
    PKSelectionController * _selectionController;
    <PKSelectionDelegate> * _selectionViewDelegate;
    bool  _visualizationsEnabled;
}

@property (nonatomic, readonly) PKController *_drawingController;
@property (nonatomic, readonly) double _fixedDrawingScale;
@property (nonatomic, readonly) struct CGSize { double x1; double x2; } _fixedPixelSize;
@property (nonatomic, readonly) bool _layerFixedPixelSize;
@property (nonatomic) bool _maintainsTransformsOnLayout;
@property (nonatomic, readonly) CHVisualizationManager *_recognitionVisualizationManager;
@property (nonatomic, readonly) <PKRendererControllerProtocol> *_rendererController;
@property (nonatomic) long long aggd_cachedVisibleStrokeCount;
@property (nonatomic, retain) UIColor *backgroundColor;
@property (nonatomic, retain) UIImage *backgroundImage;
@property (readonly, copy) NSString *debugDescription;
@property (nonatomic) <PKCanvasViewDelegate> *delegate;
@property (readonly, copy) NSString *description;
@property (nonatomic) bool disableWideGamut;
@property (nonatomic, copy) PKDrawing *drawing;
@property (getter=_drawingGestureRecognizer, nonatomic, readonly) UIGestureRecognizer *drawingGestureRecognizer;
@property (nonatomic) struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; } drawingTransform;
@property (nonatomic) SEL drawingUndoSelector;
@property (nonatomic) id drawingUndoTarget;
@property (nonatomic, retain) PKInternalDrawingView *drawingView;
@property (nonatomic, readonly) bool hasCurrentSelection;
@property (readonly) unsigned long long hash;
@property (nonatomic, copy) PKInk *ink;
@property (nonatomic, readonly) bool isDrawing;
@property (nonatomic, readonly) bool isRendering;
@property (nonatomic) double maximumZoomScale;
@property (nonatomic) double minimumZoomScale;
@property (nonatomic, retain) PKRecognitionOverlayView *overlayView;
@property (getter=_pinchGestureRecognizer, nonatomic, readonly) UIGestureRecognizer *pinchGestureRecognizer;
@property (nonatomic, retain) PKSelectionController *selectionController;
@property (nonatomic, readonly) UIView *selectionView;
@property (nonatomic) <PKSelectionDelegate> *selectionViewDelegate;
@property (nonatomic) struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; } strokeTransform;
@property (readonly) Class superclass;
@property (nonatomic) bool visualizationsEnabled;

- (void).cxx_destruct;
- (id)_drawingController;
- (void)_drawingDisplay;
- (id)_drawingGestureRecognizer;
- (struct CGSize { double x1; double x2; })_drawingSize;
- (double)_fixedDrawingScale;
- (struct CGSize { double x1; double x2; })_fixedPixelSize;
- (bool)_layerFixedPixelSize;
- (bool)_maintainsTransformsOnLayout;
- (id)_pinchGestureRecognizer;
- (id)_recognitionVisualizationManager;
- (id)_rendererController;
- (void)_setDrawing:(id)arg1 alreadyRenderedDrawing:(id)arg2 imageForAlreadyRenderedDrawing:(id)arg3 fullyRenderedCompletionBlock:(id /* block */)arg4;
- (void)_setFixedPixelSize:(struct CGSize { double x1; double x2; })arg1 drawingScale:(double)arg2;
- (void)_setFixedPointSize:(struct CGSize { double x1; double x2; })arg1 drawingScale:(double)arg2;
- (void)_setNeedsDrawingDisplay;
- (void)_setup;
- (void)_updateVisualizationSupport;
- (long long)aggd_cachedVisibleStrokeCount;
- (void)applyCommand:(id)arg1 toDrawing:(id)arg2;
- (id)backgroundColor;
- (id)backgroundImage;
- (bool)canBecomeFirstResponder;
- (bool)canBeginDrawingWithTouch:(id)arg1;
- (bool)canModifyWhitespace;
- (bool)canPerformAction:(SEL)arg1 withSender:(id)arg2;
- (id)canvasViewForToolPicker:(id)arg1;
- (struct CGPoint { double x1; double x2; })closestPointForPastedSelectionRect:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 withDrawing:(id*)arg2;
- (void)commitSelectionIfNecessaryWithCompletion:(id /* block */)arg1;
- (void)copy:(id)arg1;
- (void)cut:(id)arg1;
- (void)dealloc;
- (id)delegate;
- (void)delete:(id)arg1;
- (void)didBeginDraggingSelection;
- (void)didFinishRenderingStroke:(id)arg1 inDrawing:(id)arg2;
- (bool)disableWideGamut;
- (void)drawStrokeWithPath:(struct CGPath { }*)arg1;
- (void)drawStrokeWithPoints:(struct CGPoint { double x1; double x2; }*)arg1 count:(unsigned long long)arg2;
- (id)drawing;
- (void)drawingCancelled;
- (void)drawingDidChange:(id)arg1;
- (id)drawingForLiveAttachment;
- (id)drawingForSelectionRect:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1;
- (id)drawingForUUID:(id)arg1;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })drawingTransform;
- (SEL)drawingUndoSelector;
- (id)drawingUndoTarget;
- (id)drawingView;
- (void)duplicate:(id)arg1;
- (void)eraseAll;
- (bool)hasCurrentSelection;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })imageTransform;
- (void)imageWithCompletionBlock:(id /* block */)arg1;
- (void)initDrawingView;
- (id)initWithCoder:(id)arg1;
- (id)initWithFrame:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1;
- (id)initWithFrame:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 fixedPixelSize:(struct CGSize { double x1; double x2; })arg2 drawingScale:(double)arg3;
- (id)initWithFrame:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 fixedPixelSize:(struct CGSize { double x1; double x2; })arg2 drawingScale:(double)arg3 layerFixedPixelSize:(bool)arg4;
- (id)initWithFrame:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 selectionController:(id)arg2;
- (id)ink;
- (bool)isDrawing;
- (bool)isRendering;
- (bool)isValidDropPointForStrokes:(struct CGPoint { double x1; double x2; })arg1;
- (id)keyCommands;
- (double)layerContentScale;
- (void)layoutSubviews;
- (bool)liveDrawingIsAtEndOfDocument;
- (double)maximumZoomScale;
- (double)minimumZoomScale;
- (id)overlayView;
- (void)paste:(id)arg1;
- (void)performUndo:(id)arg1;
- (struct CGPoint { double x1; double x2; })pointInStrokeSpace:(struct CGPoint { double x1; double x2; })arg1 inDrawing:(id)arg2;
- (void)renderingDidFinish;
- (void)replaceWithStrokesFromDrawing:(id)arg1 transform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg2;
- (void)resetSelectedStrokeStateForRenderer;
- (void)scrollContent:(struct CGPoint { double x1; double x2; })arg1;
- (id)selectedInkForToolPicker:(id)arg1;
- (id)selectionController;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })selectionDrawingTransform;
- (struct CGPoint { double x1; double x2; })selectionOffsetForDrawing:(id)arg1;
- (void)selectionRefreshWithChangeToDrawings:(id)arg1;
- (id)selectionTopView;
- (id)selectionView;
- (id)selectionViewDelegate;
- (void)setAggd_cachedVisibleStrokeCount:(long long)arg1;
- (void)setBackgroundColor:(id)arg1;
- (void)setBackgroundImage:(id)arg1;
- (void)setDelegate:(id)arg1;
- (void)setDisableWideGamut:(bool)arg1;
- (void)setDrawing:(id)arg1;
- (void)setDrawingTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1;
- (void)setDrawingUndoSelector:(SEL)arg1;
- (void)setDrawingUndoTarget:(id)arg1;
- (void)setDrawingView:(id)arg1;
- (void)setHidden:(bool)arg1;
- (void)setInk:(id)arg1;
- (void)setIsDrawing:(bool)arg1;
- (void)setMaximumZoomScale:(double)arg1;
- (void)setMinimumZoomScale:(double)arg1;
- (void)setOpaque:(bool)arg1;
- (void)setOverlayView:(id)arg1;
- (void)setSelectionController:(id)arg1;
- (void)setSelectionViewDelegate:(id)arg1;
- (void)setStrokeTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1;
- (void)setVisualizationsEnabled:(bool)arg1;
- (void)set_maintainsTransformsOnLayout:(bool)arg1;
- (void)simulateHIDPoints:(id)arg1;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })strokeTransform;
- (void)toggleSelectedStrokes:(id)arg1 hide:(bool)arg2 inDrawing:(id)arg3 isErasing:(bool)arg4;
- (void)toolPicker:(id)arg1 setSelectedInk:(id)arg2;
- (id)undoManagerForToolPicker:(id)arg1;
- (id)visibleStrokesOnscreen:(id)arg1 forDrawing:(id)arg2;
- (bool)visualizationsEnabled;
- (void)willBeginDrawingWithTouch:(id)arg1;
- (void)windowDidResize:(id)arg1;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
