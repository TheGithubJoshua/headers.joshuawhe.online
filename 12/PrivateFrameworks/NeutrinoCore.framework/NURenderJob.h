<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>NURenderJob.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/NeutrinoCore.framework/NURenderJob.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/NeutrinoCore.framework/NeutrinoCore (3462.2.130)
 */

@interface NURenderJob : NSObject {
    NUComposition * _composition;
    long long  _currentStage;
    NSArray * _dependentJobs;
    <NUDevice> * _device;
    NSError * _error;
    bool  _failed;
    NUImageGeometry * _fullSizeGeometry;
    bool  _isAborted;
    bool  _isCanceled;
    bool  _isExecuting;
    bool  _isFinished;
    unsigned long long  _number;
    NUObservatory * _observatory;
    AVAudioMix * _outputAudioMix;
    NUImageGeometry * _outputGeometry;
    CIImage * _outputImage;
    AVComposition * _outputVideo;
    AVVideoComposition * _outputVideoComposition;
    NURenderNode * _prepareNode;
    NURenderNode * _renderNode;
    NURenderPipeline * _renderPipeline;
    struct { 
        long long numerator; 
        long long denominator; 
    }  _renderScale;
    int  _rendererType;
    NSObject<OS_dispatch_group> * _replyGroup;
    NURenderRequest * _request;
    NUGeometrySpaceMap * _resolvedSpaceMap;
    NSObject<OS_dispatch_queue> * _stateQueue;
    NURenderJobStatistics * _stats;
}

@property (nonatomic, retain) NUComposition *composition;
@property (readonly) long long currentStage;
@property (retain) NSArray *dependentJobs;
@property (nonatomic, readonly) <NUDevice> *device;
@property (readonly) NSError *error;
@property (readonly) <NUExtentPolicy> *extentPolicy;
@property (readonly) bool failed;
@property (nonatomic, retain) NUImageGeometry *fullSizeGeometry;
@property (readonly) struct { long long x1; long long x2; } imageSize;
@property (readonly) bool isAborted;
@property (readonly) bool isCanceled;
@property (readonly) bool isExecuting;
@property (readonly) bool isFinished;
@property (readonly) unsigned long long number;
@property (nonatomic, retain) AVAudioMix *outputAudioMix;
@property (nonatomic, retain) NUImageGeometry *outputGeometry;
@property (nonatomic, retain) CIImage *outputImage;
@property (nonatomic, retain) AVComposition *outputVideo;
@property (nonatomic, retain) AVVideoComposition *outputVideoComposition;
@property (nonatomic, retain) NURenderNode *prepareNode;
@property (readonly) NUPriority *priority;
@property (nonatomic, retain) NURenderNode *renderNode;
@property (nonatomic, retain) NURenderPipeline *renderPipeline;
@property (nonatomic) struct { long long x1; long long x2; } renderScale;
@property (nonatomic, readonly) <NURenderer> *renderer;
@property (nonatomic, readonly) int rendererType;
@property (nonatomic, retain) NSObject<OS_dispatch_group> *replyGroup;
@property (readonly) NURenderRequest *request;
@property (nonatomic, retain) NUGeometrySpaceMap *resolvedSpaceMap;
@property (readonly) <NUScalePolicy> *scalePolicy;
@property (nonatomic, readonly) <NURenderStatistics> *statistics;
@property (readonly) bool succeeded;
@property (nonatomic, readonly) bool wantsCompleteStage;
@property (nonatomic, readonly) bool wantsOutputGeometry;
@property (nonatomic, readonly) bool wantsOutputImage;
@property (nonatomic, readonly) bool wantsOutputVideo;
@property (nonatomic, readonly) bool wantsOutputVideoFrame;
@property (nonatomic, readonly) bool wantsPrepareNodeCached;
@property (nonatomic, readonly) bool wantsRenderNodeCached;
@property (nonatomic, readonly) bool wantsRenderScaleClampedToNativeScale;
@property (nonatomic, readonly) bool wantsRenderStage;

- (void).cxx_destruct;
- (struct { bool x1; bool x2; })_atomicCancel;
- (void)_cancel;
- (void)_cancelCoalescedJob;
- (void)_didPrepare;
- (void)_finish;
- (long long)_nextStageForStage:(long long)arg1;
- (void)_notifyCanceled:(long long)arg1;
- (void)_notifyStageTransition:(long long)arg1;
- (void)_reply:(id)arg1;
- (void)_run:(long long)arg1;
- (void)_setCurrentStage:(long long)arg1;
- (bool)_shouldCancelCoalescedJob;
- (bool)_shouldWaitForDependentJobs;
- (void)abortComplete;
- (void)abortPrepare;
- (void)abortRender;
- (void)abortStage:(long long)arg1;
- (void)addCancelObserver:(id)arg1 queue:(id)arg2 block:(id /* block */)arg3;
- (void)addStageObserver:(id)arg1 queue:(id)arg2 block:(id /* block */)arg3;
- (void)cancel;
- (void)cancelCoalescedJob;
- (void)cleanUp;
- (bool)complete:(out id*)arg1;
- (id)composition;
- (long long)currentStage;
- (id)dependentJobs;
- (id)description;
- (id)device;
- (void)didRun;
- (id)error;
- (id)evaluateComposition:(id)arg1 pipeline:(id)arg2 pipelineState:(id)arg3 error:(out id*)arg4;
- (id)evaluateOutputGeometry:(out id*)arg1;
- (id)extentPolicy;
- (void)fail:(id)arg1;
- (bool)failed;
- (void)finalize:(bool)arg1;
- (void)finish;
- (id)fullSizeGeometry;
- (id)generateVideoComposition:(out id*)arg1;
- (struct { long long x1; long long x2; })imageSize;
- (id)init;
- (id)initWithRequest:(id)arg1;
- (bool)isAborted;
- (bool)isCanceled;
- (bool)isExecuting;
- (bool)isFinished;
- (id)newRenderPipelineStateForEvaluationMode:(long long)arg1;
- (unsigned long long)number;
- (id)outputAudioMix;
- (id)outputGeometry;
- (id)outputImage;
- (id)outputVideo;
- (id)outputVideoComposition;
- (id)pipelineForComposition:(id)arg1 error:(out id*)arg2;
- (bool)prepare:(out id*)arg1;
- (id)prepareNode;
- (id)prepareNodeWithPipelineState:(id)arg1 error:(out id*)arg2;
- (id)priority;
- (void)removeObserver:(id)arg1;
- (bool)render:(out id*)arg1;
- (id)renderImage:(id)arg1 into:(id)arg2 colorSpace:(id)arg3 roi:(id)arg4 imageSize:(struct { long long x1; long long x2; })arg5 error:(out id*)arg6;
- (id)renderNode;
- (id)renderNodeWithPipelineState:(id)arg1 error:(out id*)arg2;
- (id)renderPipeline;
- (struct { long long x1; long long x2; })renderScale;
- (bool)renderVideoFrames:(id)arg1 intoPixelBuffer:(struct __CVBuffer { }*)arg2 time:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg3 colorSpace:(id)arg4 error:(out id*)arg5;
- (id)renderer;
- (int)rendererType;
- (void)reply:(id)arg1;
- (id)replyGroup;
- (id)request;
- (bool)requiresVideoComposition;
- (long long)resolvedSampleMode:(long long)arg1;
- (id)resolvedSpaceMap;
- (void)respond;
- (id)result;
- (void)run:(long long)arg1;
- (bool)runStage:(long long)arg1 error:(out id*)arg2;
- (id)scalePolicy;
- (void)setComposition:(id)arg1;
- (void)setDependentJobs:(id)arg1;
- (void)setFullSizeGeometry:(id)arg1;
- (void)setOutputAudioMix:(id)arg1;
- (void)setOutputGeometry:(id)arg1;
- (void)setOutputImage:(id)arg1;
- (void)setOutputVideo:(id)arg1;
- (void)setOutputVideoComposition:(id)arg1;
- (void)setPrepareNode:(id)arg1;
- (void)setRenderNode:(id)arg1;
- (void)setRenderPipeline:(id)arg1;
- (void)setRenderScale:(struct { long long x1; long long x2; })arg1;
- (void)setReplyGroup:(id)arg1;
- (void)setResolvedSpaceMap:(id)arg1;
- (id)statistics;
- (bool)succeeded;
- (id)validateComposition:(out id*)arg1;
- (bool)wantsCompleteStage;
- (bool)wantsOutputGeometry;
- (bool)wantsOutputImage;
- (bool)wantsOutputVideo;
- (bool)wantsOutputVideoFrame;
- (bool)wantsPrepareNodeCached;
- (bool)wantsRenderNodeCached;
- (bool)wantsRenderScaleClampedToNativeScale;
- (bool)wantsRenderStage;
- (long long)willRun;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
