<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>VKTileProvider.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/VectorKit.framework/VKTileProvider.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/VectorKit.framework/VectorKit (1360.35.12.18.4)
 */

@interface VKTileProvider : NSObject <VKLRUCacheDelegate, VKTileSourceClient> {
    bool  _canceled;
    <VKTileProviderClient> * _client;
    double  _contentScale;
    <VKMapLayer> * _debugLayer;
    GEOTileKeyList * _debugLayerKeys;
    bool  _enableIntegrityCheck;
    _VKTileProviderTimerTarget * _evaluationTarget;
    VKTimer * _evaluationTimer;
    bool  _exclusionAreaVisible;
    struct vector<md::TileExclusionArea, std::__1::allocator<md::TileExclusionArea> > { 
        struct TileExclusionArea {} *__begin_; 
        struct TileExclusionArea {} *__end_; 
        struct __compressed_pair<md::TileExclusionArea *, std::__1::allocator<md::TileExclusionArea> > { 
            struct TileExclusionArea {} *__value_; 
        } __end_cap_; 
    }  _exclusionAreas;
    unsigned char  _fallbackFunction;
    NSMutableSet * _fallbackTiles;
    bool  _finishedLoading;
    bool  _finishedLoadingOptionalLayers;
    bool  _hasFailedTile;
    NSArray * _holes;
    double  _integrityInternval;
    VKTileKeyList * _keysInView;
    struct VKCameraState { 
        struct RigidTransform<double> { 
            struct Quaternion<double> { 
                struct Matrix<double, 3, 1> { 
                    double _e[3]; 
                } _imaginary; 
                double _scalar; 
            } _rotation; 
            struct Matrix<double, 3, 1> { 
                double _e[3]; 
            } _translation; 
        } transform; 
        double aspectRatio; 
        double verticalFieldOfView; 
        double horizontalOffset; 
    }  _lastCameraState;
    struct CGSize { 
        double width; 
        double height; 
    }  _lastCanvasSize;
    double  _lastFetchTime;
    double  _lastHoleLogTime;
    double  _lastIntegrityCheckLog;
    float  _lastMidDisplayZoomLevel;
    double  _lastSelectTime;
    float  _loadingProgress;
    NSLocale * _locale;
    NSMutableSet * _lostTiles;
    GEOResourceManifestConfiguration * _manifestConfiguration;
    double  _maxTimeInLoadingState;
    double  _minTimeInLoadingState;
    int  _mode;
    VKTileKeyList * _neighborKeys;
    unsigned long long  _neighborMode;
    NSMutableSet * _neighborTiles;
    VKTileSource * _optionalTileSources;
    bool  _prefetchEnabled;
    VKTileKeyList * _prefetchKeys;
    unsigned int  _prefetchNumberOfScreens;
    _VKTileProviderTimerTarget * _prefetchTarget;
    VKTimer * _prefetchTimer;
    VKTileKeyList * _previousTiles;
    VKMapRasterizer * _rasterizer;
    struct { 
        double x; 
        double y; 
    }  _sortPoint;
    struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { 
        struct StylesheetManager<gss::PropertyID> {} *__ptr_; 
        struct __shared_weak_count {} *__cntrl_; 
    }  _styleManager;
    struct shared_ptr<md::TaskContext> { 
        struct TaskContext {} *__ptr_; 
        struct __shared_weak_count {} *__cntrl_; 
    }  _taskContext;
    VKTileCache * _tilePool;
    bool  _tileProviderHasBadTiles;
    unsigned long long  _tileReserveLimit;
    struct unique_ptr<md::TileSelector, std::__1::default_delete<md::TileSelector> > { 
        struct __compressed_pair<md::TileSelector *, std::__1::default_delete<md::TileSelector> > { 
            struct TileSelector {} *__value_; 
        } __ptr_; 
    }  _tileSelector;
    bool  _tilesChanged;
    VKTileSource * _tilesSources;
    NSMutableSet * _tilesToRender;
    bool  _useSmallTileCache;
    bool  _useStableFallback;
}

@property (getter=isCanceled, nonatomic, readonly) bool canceled;
@property (nonatomic) <VKTileProviderClient> *client;
@property (nonatomic) double contentScale;
@property (readonly, copy) NSString *debugDescription;
@property (nonatomic, retain) <VKMapLayer> *debugLayer;
@property (nonatomic, readonly) GEOTileKeyList *debugLayerKeys;
@property (readonly, copy) NSString *description;
@property (nonatomic) unsigned char fallbackFunction;
@property (getter=isFinishedLoading, nonatomic, readonly) bool finishedLoading;
@property (getter=isFinishedLoadingOptionalLayers, nonatomic, readonly) bool finishedLoadingOptionalLayers;
@property (nonatomic, readonly) bool hasFailedTile;
@property (readonly) unsigned long long hash;
@property (nonatomic, readonly) VKTileKeyList *keysInView;
@property (nonatomic, readonly) float loadingProgress;
@property (nonatomic) double lodBias;
@property (nonatomic) int mode;
@property (nonatomic, readonly) VKTileKeyList *neighborKeys;
@property (nonatomic) unsigned long long neighborMode;
@property (nonatomic, readonly) NSSet *neighborTiles;
@property (getter=isPrefetchEnabled, nonatomic) bool prefetchEnabled;
@property (nonatomic) struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x1; struct __shared_weak_count {} *x2; } styleManager;
@property (readonly) Class superclass;
@property (nonatomic, readonly) NSSet *tilesToRender;
@property (nonatomic) bool useStableFallback;
@property (nonatomic, readonly) NSArray *visibleTileSets;

- (id).cxx_construct;
- (void).cxx_destruct;
- (void)_dirtyTile:(id)arg1 source:(id)arg2 layer:(unsigned char)arg3;
- (void)_disableTimers;
- (void)_fetchAvailableTiles:(bool)arg1;
- (void)_fillHoles:(id)arg1 context:(struct LayoutContext { id x1; struct shared_ptr<md::ViewTransform> { struct ViewTransform {} *x_2_1_1; struct __shared_weak_count {} *x_2_1_2; } x2; struct shared_ptr<md::AnchorContext> { struct AnchorContext {} *x_3_1_1; struct __shared_weak_count {} *x_3_1_2; } x3; id x4; id x5; struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x_6_1_1; struct __shared_weak_count {} *x_6_1_2; } x6; struct shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> > { struct StylesheetManager<gss::ScenePropertyID> {} *x_7_1_1; struct __shared_weak_count {} *x_7_1_2; } x7; struct VKEdgeInsets { float x_8_1_1; float x_8_1_2; float x_8_1_3; float x_8_1_4; } x8; struct VKEdgeInsets { float x_9_1_1; float x_9_1_2; float x_9_1_3; float x_9_1_4; } x9; unsigned char x10; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_11_1_1; struct __shared_weak_count {} *x_11_1_2; } x11; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_12_1_1; struct __shared_weak_count {} *x_12_1_2; } x12; }*)arg2;
- (void)_prefetchTiles;
- (void)_resizeCache;
- (unsigned long long)_tileStateForKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg1 forLayer:(unsigned char)arg2;
- (void)_updateTimers:(int)arg1;
- (void)bestAccuracyFallbackForHoles:(id)arg1 context:(struct LayoutContext { id x1; struct shared_ptr<md::ViewTransform> { struct ViewTransform {} *x_2_1_1; struct __shared_weak_count {} *x_2_1_2; } x2; struct shared_ptr<md::AnchorContext> { struct AnchorContext {} *x_3_1_1; struct __shared_weak_count {} *x_3_1_2; } x3; id x4; id x5; struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x_6_1_1; struct __shared_weak_count {} *x_6_1_2; } x6; struct shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> > { struct StylesheetManager<gss::ScenePropertyID> {} *x_7_1_1; struct __shared_weak_count {} *x_7_1_2; } x7; struct VKEdgeInsets { float x_8_1_1; float x_8_1_2; float x_8_1_3; float x_8_1_4; } x8; struct VKEdgeInsets { float x_9_1_1; float x_9_1_2; float x_9_1_3; float x_9_1_4; } x9; unsigned char x10; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_11_1_1; struct __shared_weak_count {} *x_11_1_2; } x11; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_12_1_1; struct __shared_weak_count {} *x_12_1_2; } x12; }*)arg2 previousTiles:(id)arg3;
- (bool)cache:(id)arg1 willEvictObject:(id)arg2 forKey:(const struct VKCacheKey { unsigned int x1; unsigned int x2; unsigned int x3; unsigned int x4; }*)arg3;
- (bool)canRenderTile:(id)arg1;
- (void)cancelLoadForMapTile:(id)arg1;
- (void)cancelLoadingTiles;
- (void)changeTileForKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg1 toState:(unsigned long long)arg2 withError:(id)arg3 withTile:(id)arg4 forLayer:(unsigned char)arg5;
- (bool)checkMapTileIntegrity:(id)arg1 errors:(id)arg2;
- (void)clearScene;
- (id)client;
- (void)configureTileSelection;
- (double)contentScale;
- (void)dealloc;
- (id)debugLayer;
- (id)debugLayerKeys;
- (id)describeReasonForTileBeingHole:(id)arg1 atTime:(double)arg2;
- (void)describeTilesFromList:(id)arg1 output:(id)arg2;
- (void)describeTilesFromList:(id)arg1 outputtoDict:(id)arg2;
- (id)detailedDescription;
- (id)detailedDescriptionDictionaryRepresentation;
- (void)didStopLoadingTilesWithError:(id)arg1;
- (void)dirtyTile:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg1 source:(id)arg2;
- (void)dirtyTilesFromTileSource:(id)arg1;
- (void)dirtyTilesFromTileSource:(id)arg1 withState:(unsigned long long)arg2;
- (id)errorsForRequiredLayers;
- (bool)evaluateNeighborTileForRendering:(id)arg1;
- (bool)evaluateSelectedTileForRendering:(id)arg1;
- (unsigned char)fallbackFunction;
- (void)flushCaches:(bool)arg1;
- (void)foreachActiveLayer:(id /* block */)arg1;
- (void)foreachOptionalLayer:(id /* block */)arg1;
- (bool)hasAllTileData:(id)arg1;
- (bool)hasFailedTile;
- (bool)hasRequiredTileData:(id)arg1;
- (bool)inFailedState:(id)arg1;
- (id)initWithClient:(id)arg1 resourceManifestConfiguration:(id)arg2 locale:(id)arg3 taskContext:(struct shared_ptr<md::TaskContext> { struct TaskContext {} *x1; struct __shared_weak_count {} *x2; })arg4 tileSelectionProfile:(struct unique_ptr<md::TileSelectionProfile, std::__1::default_delete<md::TileSelectionProfile> > { struct __compressed_pair<md::TileSelectionProfile *, std::__1::default_delete<md::TileSelectionProfile> > { struct TileSelectionProfile {} *x_1_1_1; } x1; }*)arg5;
- (void)invalidateRasterizedTiles;
- (void)invalidateTilesFromTileSource:(id)arg1;
- (bool)isCanceled;
- (bool)isFinishedLoading;
- (bool)isFinishedLoadingOptionalLayers;
- (bool)isPrefetchEnabled;
- (id)keysInView;
- (unsigned char)layerForSource:(id)arg1;
- (float)loadingProgress;
- (double)lodBias;
- (void)logIntegrityCheck;
- (void)logPersistentHoles;
- (int)mode;
- (id)neighborKeys;
- (unsigned long long)neighborMode;
- (id)neighborTiles;
- (void)populateDebugNode:(struct shared_ptr<md::DebugTreeNode> { struct DebugTreeNode {} *x1; struct __shared_weak_count {} *x2; })arg1;
- (void)populateDebugNodeForKeys:(struct shared_ptr<md::DebugTreeNode> { struct DebugTreeNode {} *x1; struct __shared_weak_count {} *x2; })arg1 keys:(id)arg2;
- (void)populateDebugNodeForTiles:(struct shared_ptr<md::DebugTreeNode> { struct DebugTreeNode {} *x1; struct __shared_weak_count {} *x2; })arg1 tiles:(id)arg2;
- (void)prepareTileForRendering:(id)arg1;
- (void)quiesce;
- (void)rasterizer:(id)arg1 didMakeRasterTile:(id)arg2 forKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg3;
- (void)releaseBestAccuracyFallbackTilesForTile:(id)arg1 context:(struct LayoutContext { id x1; struct shared_ptr<md::ViewTransform> { struct ViewTransform {} *x_2_1_1; struct __shared_weak_count {} *x_2_1_2; } x2; struct shared_ptr<md::AnchorContext> { struct AnchorContext {} *x_3_1_1; struct __shared_weak_count {} *x_3_1_2; } x3; id x4; id x5; struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x_6_1_1; struct __shared_weak_count {} *x_6_1_2; } x6; struct shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> > { struct StylesheetManager<gss::ScenePropertyID> {} *x_7_1_1; struct __shared_weak_count {} *x_7_1_2; } x7; struct VKEdgeInsets { float x_8_1_1; float x_8_1_2; float x_8_1_3; float x_8_1_4; } x8; struct VKEdgeInsets { float x_9_1_1; float x_9_1_2; float x_9_1_3; float x_9_1_4; } x9; unsigned char x10; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_11_1_1; struct __shared_weak_count {} *x_11_1_2; } x11; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_12_1_1; struct __shared_weak_count {} *x_12_1_2; } x12; }*)arg2 previousTiles:(id)arg3;
- (void)releaseFallbackTileForRendering:(id)arg1;
- (void)releaseNeighborTileForRendering:(id)arg1;
- (void)releaseTileForRendering:(id)arg1;
- (void)removeTileSourceForMapLayer:(unsigned char)arg1;
- (void)requireRasterization:(id)arg1;
- (void)rescindOverlappedTiles;
- (void)rescindTileForRendering:(id)arg1;
- (void)retireNeighborTiles:(id)arg1;
- (void)retireRenderTiles:(id)arg1;
- (id)selectTiles:(int*)arg1 needRasterization:(bool*)arg2;
- (void)setClient:(id)arg1;
- (void)setContentScale:(double)arg1;
- (void)setDebugLayer:(id)arg1;
- (void)setFallbackFunction:(unsigned char)arg1;
- (void)setLodBias:(double)arg1;
- (void)setMode:(int)arg1;
- (void)setNeighborMode:(unsigned long long)arg1;
- (void)setPrefetchEnabled:(bool)arg1;
- (void)setStyleManager:(struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x1; struct __shared_weak_count {} *x2; })arg1;
- (void)setTileExclusionAreas:(const struct vector<md::TileExclusionArea, std::__1::allocator<md::TileExclusionArea> > { struct TileExclusionArea {} *x1; struct TileExclusionArea {} *x2; struct __compressed_pair<md::TileExclusionArea *, std::__1::allocator<md::TileExclusionArea> > { struct TileExclusionArea {} *x_3_1_1; } x3; }*)arg1;
- (void)setTileSource:(id)arg1 forMapLayer:(unsigned char)arg2 optional:(bool)arg3;
- (void)setUseStableFallback:(bool)arg1;
- (id)sourceForLayer:(unsigned char)arg1;
- (id)sourceForMapLayer:(id)arg1;
- (struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x1; struct __shared_weak_count {} *x2; })styleManager;
- (bool)tile:(id)arg1 hasBecomeTerminalSince:(double)arg2;
- (bool)tileExclusionAreaVisible;
- (id)tileForKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg1;
- (bool)tileMatters:(id)arg1;
- (void)tileSource:(id)arg1 didFailToDecodeTileForKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg2;
- (void)tileSource:(id)arg1 didFailToLoadTileForKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg2 error:(id)arg3;
- (void)tileSource:(id)arg1 didFetchTile:(id)arg2 forKey:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg3;
- (void)tileSource:(id)arg1 dirtyTilesWithinRect:(const struct Box<double, 2> { struct Matrix<double, 2, 1> { double x_1_1_1[2]; } x1; struct Matrix<double, 2, 1> { double x_2_1_1[2]; } x2; }*)arg2 level:(long long)arg3;
- (void)tileSource:(id)arg1 invalidateKeys:(id)arg2;
- (void)tileSource:(id)arg1 invalidateTilesWithStatePredicate:(id /* block */)arg2;
- (bool)tileSource:(id)arg1 keyIsNeeded:(const struct VKTileKey { unsigned int x1; int x2; int x3; unsigned int x4; }*)arg2;
- (long long)tileSource:(id)arg1 overrideForMaximumZoomLevel:(long long)arg2;
- (void)tileSourcesDidChange;
- (void)tileStatusFromList:(id)arg1 canRender:(out id*)arg2 canNotRender:(out id*)arg3;
- (id)tilesToRender;
- (double)timeTileLastUpdatedHoleStatus:(id)arg1;
- (void)timerFired:(id)arg1;
- (void)updateWithContext:(struct LayoutContext { id x1; struct shared_ptr<md::ViewTransform> { struct ViewTransform {} *x_2_1_1; struct __shared_weak_count {} *x_2_1_2; } x2; struct shared_ptr<md::AnchorContext> { struct AnchorContext {} *x_3_1_1; struct __shared_weak_count {} *x_3_1_2; } x3; id x4; id x5; struct shared_ptr<gss::StylesheetManager<gss::PropertyID> > { struct StylesheetManager<gss::PropertyID> {} *x_6_1_1; struct __shared_weak_count {} *x_6_1_2; } x6; struct shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> > { struct StylesheetManager<gss::ScenePropertyID> {} *x_7_1_1; struct __shared_weak_count {} *x_7_1_2; } x7; struct VKEdgeInsets { float x_8_1_1; float x_8_1_2; float x_8_1_3; float x_8_1_4; } x8; struct VKEdgeInsets { float x_9_1_1; float x_9_1_2; float x_9_1_3; float x_9_1_4; } x9; unsigned char x10; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_11_1_1; struct __shared_weak_count {} *x_11_1_2; } x11; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_12_1_1; struct __shared_weak_count {} *x_12_1_2; } x12; }*)arg1 selectionScale:(float)arg2;
- (bool)useStableFallback;
- (id)visibleTileSets;
- (void)willStartLoadingTiles;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
