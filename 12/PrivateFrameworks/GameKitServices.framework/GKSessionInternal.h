<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GKSessionInternal.h</title>
    <meta name="viewport" content="width=device-width">
    <style>
    body { margin: 1em; }
    pre { font: 11pt/1.25 ui-monospace, "SF Mono", Menlo, monospace; }
    a { color: #af52de; }
    pre { white-space: pre-wrap; }
    header, footer { color: #8e8e93; }
    header { white-space: pre; }
    footer { max-width: 700px; }
    hr { border: 0; border-top: 1px solid #c6c6c8; }
    .download { text-decoration: none; }
    @media (prefers-color-scheme: dark) {
        body { background: black; color: white; }
        a { color: #bf5af2; }
        hr { border-top-color: #333335; }
    }
    </style>
</head>
<body>
<pre><header>
 ___          _   _             ___
| _ \_  _ _ _| |_(_)_ __  ___  | _ )_ _ _____ __ _____ ___ _ _
|   / || | ' \  _| | '  \/ -_) | _ \ '_/ _ \ V  V (_-// -_) '_|
|_|_\\_,_|_||_\__|_|_|_|_\___| |___/_| \___/\_/\_//__/\___|_|


</header><hr>

/PrivateFrameworks/GameKitServices.framework/GKSessionInternal.h <a href="?download" download title="Download" class="download">&darr;</a>


/* Generated by RuntimeBrowser
   Platform: iOS 12.5.7 (16H81) arm64
   Image: /System/Library/PrivateFrameworks/GameKitServices.framework/GameKitServices (1475.1.8)
 */

@interface GKSessionInternal : NSObject {
    GKConnection * _connection;
    id  _dataReceiveHandler;
    void * _dataReceiveHandlerContext;
    id  _delegate;
    struct _opaque_pthread_mutex_t { 
        long long __sig; 
        BOOL __opaque[56]; 
    }  _delegateLock;
    NSString * _displayName;
    struct _DNSServiceRef_t { } * _dnsServiceConnection;
    struct _DNSServiceRef_t { } * _dnsServiceResolveConnection;
    <GKSessionDOOBReceiveHandler> * _doobReceiveHandler;
    void * _doobReceiveHandlerContext;
    bool  _handleEventsRunning;
    bool  _isBusy;
    bool  _isPublishing;
    bool  _isSearching;
    struct _opaque_pthread_mutex_t { 
        long long __sig; 
        BOOL __opaque[56]; 
    }  _lock;
    int  _mode;
    struct _DNSServiceRef_t { } * _oldService;
    GKAutoPeerIDTable * _peerIDTable;
    GKTable * _peerInfoTable;
    GKTable * _peerNameTable;
    GKList * _peersAvailable;
    GKList * _peersConnected;
    GKList * _peersForCleanup;
    GKList * _peersPendingIncomingInvitation;
    GKList * _peersPendingOutgoingInvitation;
    unsigned int  _pid;
    unsigned long long  _port;
    id  _privateDelegate;
    int  _sReset;
    struct _DNSServiceRef_t { } * _service;
    struct _DNSServiceRef_t { } * _serviceBrowser;
    GKSession * _session;
    bool  _sessionStarted;
    bool  _shutdown;
    bool  _stopHandlingEvents;
    GKVoiceChatSessionListener * _voiceChatListener;
    bool  _wifiEnabled;
    struct OpaqueAGPSession { } * agpSessionRef;
    double  disconnectTimeout;
    NSString * domain;
    unsigned long long  maxPeers;
    NSString * serviceType;
    NSString * sessionID;
    struct OpaqueGCKSession { } * sessionRef;
}

@property (nonatomic) struct OpaqueAGPSession { }*agpSessionRef;
@property (getter=isAvailable) bool available;
@property (getter=isBusy) bool busy;
@property (readonly, retain) GKConnection *connection;
@property (nonatomic, readonly) id dataReceiveHandler;
@property <GKSessionDelegate> *delegate;
@property double disconnectTimeout;
@property (readonly) NSString *displayName;
@property (nonatomic, copy) NSString *domain;
@property (nonatomic) unsigned long long maxPeers;
@property (readonly) NSString *peerID;
@property (nonatomic) unsigned long long port;
@property <GKSessionPrivateDelegate> *privateDelegate;
@property (nonatomic, copy) NSString *serviceType;
@property (readonly) NSString *sessionID;
@property (readonly) int sessionMode;
@property (nonatomic) struct OpaqueGCKSession { }*sessionRef;
@property bool wifiEnabled;

- (bool)acceptConnectionFromPeer:(id)arg1 error:(id*)arg2;
- (struct OpaqueAGPSession { }*)agpSessionRef;
- (void)browse;
- (void)cancelConnectToPeer:(id)arg1;
- (bool)checkDNSConnection;
- (void)cleanupExAvailablePeers;
- (void)connectToPeer:(id)arg1 withTimeout:(double)arg2;
- (id)connection;
- (id)dataReceiveHandler;
- (void)dealloc;
- (id)delegate;
- (void)denyConnectionFromPeer:(id)arg1;
- (id)description;
- (void)didFindService:(const char *)arg1 fromIF:(const char *)arg2 withError:(int)arg3 moreComing:(bool)arg4;
- (void)didLookupHostname:(struct _DNSServiceRef_t { }*)arg1 forPeer:(id)arg2 hostName:(const char *)arg3 address:(const struct sockaddr_in { unsigned char x1; unsigned char x2; unsigned short x3; struct in_addr { unsigned int x_4_1_1; } x4; BOOL x5[8]; }*)arg4 interface:(unsigned int)arg5 withError:(int)arg6 moreComing:(bool)arg7;
- (void)didPublishWithError:(int)arg1;
- (void)didRemoveService:(const char *)arg1 fromIF:(const char *)arg2 withError:(int)arg3 moreComing:(bool)arg4;
- (void)didResolveService:(struct _DNSServiceRef_t { }*)arg1 forPeer:(id)arg2 hostName:(const char *)arg3 port:(unsigned short)arg4 interface:(unsigned int)arg5 txtLen:(unsigned short)arg6 txtRecord:(const void*)arg7 withError:(int)arg8 moreComing:(bool)arg9;
- (void)didUpdateTXTRecordForPeer:(id)arg1 fromIF:(const char *)arg2 txtLen:(unsigned short)arg3 txtRecord:(const void*)arg4 withError:(int)arg5 moreComing:(bool)arg6;
- (void)disconnectFromAllPeers;
- (void)disconnectPeerFromAllPeers:(id)arg1;
- (double)disconnectTimeout;
- (id)displayName;
- (id)displayNameForPeer:(id)arg1;
- (id)domain;
- (bool)filterService:(const char *)arg1 withPID:(unsigned int)arg2;
- (void)handleEvents;
- (id)initWithConnection:(id)arg1 session:(id)arg2 delegate:(id)arg3;
- (id)initWithSessionID:(id)arg1 displayName:(id)arg2 session:(id)arg3 sessionMode:(int)arg4;
- (bool)isAvailable;
- (bool)isBusy;
- (bool)isPeerBusy:(id)arg1;
- (bool)isShuttingDown;
- (void)lock;
- (unsigned long long)maxPeers;
- (id)newNSErrorFromGKSessionError:(int)arg1 description:(id)arg2 reason:(id)arg3;
- (id)newNSErrorFromHRESULT:(int)arg1 description:(id)arg2 reason:(id)arg3;
- (bool)parseServiceName:(const char *)arg1 intoDisplayName:(id*)arg2 pid:(unsigned int*)arg3 state:(id*)arg4;
- (bool)passesSendDataSanityCheck:(id)arg1 toPeers:(id)arg2 withDataMode:(int)arg3 error:(id*)arg4;
- (id)peerID;
- (id)peersWithConnectionState:(int)arg1;
- (unsigned long long)port;
- (void)printDictionaries;
- (id)privateDelegate;
- (void)processTXTRecordForPeer:(id)arg1 txtLen:(unsigned short)arg2 txtRecord:(const void*)arg3;
- (void)publish;
- (void)receiveDOOB:(id)arg1 fromPeer:(id)arg2 inSession:(id)arg3 context:(void*)arg4;
- (void)reset;
- (bool)sendAudioData:(id)arg1 toPeers:(id)arg2 withDataMode:(int)arg3 error:(id*)arg4;
- (void)sendCallbacksToDelegate:(struct { int x1; char *x2; int x3; unsigned int x4; }*)arg1 remotePeer:(unsigned int)arg2;
- (bool)sendData:(id)arg1 toPeers:(id)arg2 withDataMode:(int)arg3 enableOOB:(bool)arg4 error:(id*)arg5;
- (bool)sendData:(id)arg1 toPeers:(id)arg2 withDataMode:(int)arg3 error:(id*)arg4;
- (bool)sendDataToAllPeers:(id)arg1 withDataMode:(int)arg2 error:(id*)arg3;
- (id)serviceName;
- (id)serviceType;
- (id)sessionID;
- (int)sessionMode;
- (struct OpaqueGCKSession { }*)sessionRef;
- (void)setAgpSessionRef:(struct OpaqueAGPSession { }*)arg1;
- (void)setAvailable:(bool)arg1;
- (void)setBusy:(bool)arg1;
- (void)setDOOBReceiveHandler:(id)arg1 withContext:(void*)arg2 inBand:(unsigned int)arg3;
- (void)setDataReceiveHandler:(id)arg1 withContext:(void*)arg2;
- (void)setDelegate:(id)arg1;
- (void)setDisconnectTimeout:(double)arg1;
- (void)setDisplayName:(id)arg1 forPeer:(unsigned int)arg2;
- (void)setDomain:(id)arg1;
- (void)setMaxPeers:(unsigned long long)arg1;
- (void)setPort:(unsigned long long)arg1;
- (void)setPrivateDelegate:(id)arg1;
- (void)setServiceType:(id)arg1;
- (void)setSessionRef:(struct OpaqueGCKSession { }*)arg1;
- (void)setWifiEnabled:(bool)arg1;
- (void)stopOldService;
- (void)stopResolvingAllPeers;
- (id)stringForGCKID:(unsigned int)arg1;
- (void)tellDelegate_connectionRequestToPeerFailed:(id)arg1;
- (void)tellDelegate_didConnectPeer:(id)arg1;
- (void)tellDelegate_didDisconnectPeer:(id)arg1;
- (void)tellDelegate_didReceiveBand_RetryICE:(id)arg1;
- (void)tellDelegate_didReceiveData:(id)arg1;
- (void)tellDelegate_gotInvited:(id)arg1;
- (void)tellDelegate_initiateRelay:(id)arg1;
- (void)tellDelegate_isConnectingPeer:(id)arg1;
- (void)tellDelegate_networkStatisticsChanged:(id)arg1;
- (void)tellDelegate_peerDidBecomeAvailable:(id)arg1;
- (void)tellDelegate_peerDidBecomeBusy:(id)arg1;
- (void)tellDelegate_peerDidBecomeUnavailable:(id)arg1;
- (void)tellDelegate_sessionDidFailWithError:(id)arg1;
- (void)tellDelegate_updateRelay:(id)arg1;
- (void)timeoutConnectToPeer:(id)arg1;
- (bool)tryConnectToPeer:(id)arg1;
- (void)unlock;
- (id)voiceChatSessionListener;
- (bool)wifiEnabled;

@end


<hr><footer>
Source code: <a href="https://github.com/hbang/RuntimeBrowser">https://github.com/hbang/RuntimeBrowser</a>

Authors:
  Ezra Epstein (eepstein@prajna.com)
  Nicolas Seriot (nicolas@seriot.ch)
  HASHBANG Productions

Copyright &copy; 2002 by Prajna IT Consulting
Copyright &copy; 2015 by <a href="http://www.seriot.ch">Nicolas Seriot</a>
Copyright &copy; 2021 by <a href="https://hashbang.productions">HASHBANG Productions</a>

THIS PROGRAM AND THIS CODE COME WITH ABSOLUTELY NO WARRANTY. THIS CODE HAS BEEN PROVIDED "AS IS" AND THE RESPONSIBILITY FOR ITS OPERATIONS IS 100% YOURS.

RuntimeBrowser is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

RuntimeBrowser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RuntimeBrowser (in a file called "COPYING.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</footer></pre>
</body>
</html>
